import { AnalysisResult } from '../types';

export const generateMarkdownReport = (result: AnalysisResult): string => {
  let markdown = `# Nolvaryn Email Analysis Report

## Report Details

- **Generated on**: ${new Date().toLocaleString()}
- **Generated by**: Nolvaryn Email Security Platform
- **Analysis Time**: ${result.analysisTime ? `${Math.round(result.analysisTime / 1000)} seconds` : 'N/A'}
- **File Hash**: ${result.emailInfo?.fileHash || 'N/A'}

---

## Executive Summary

### Risk Score
**${result.phishingProbability}/100**

### Risk Level
**${result.riskLevel || 'Unknown'}**

### Risk Score Explanation
${result.phishingProbabilityExplanation}

### Authentication Status
| Protocol | Status |
|----------|--------|
| SPF | ${result.headerAnalysis?.spfResult?.status || 'N/A'} |
| DKIM | ${result.headerAnalysis?.dkimResult?.status || 'N/A'} |
| DMARC | ${result.headerAnalysis?.dmarcResult?.status || 'N/A'} |

### Key Statistics
- **Total URLs Analyzed**: ${(result.urls || []).length}
- **Suspicious URLs**: ${(result.urls || []).filter(u => u.verdict === 'Caution' || u.verdict === 'Suspicious').length}
- **Total Attachments**: ${(result.attachments || []).length}
- **High-Risk Attachments**: ${(result.attachments || []).filter(a => a.warning.toLowerCase().includes('high-risk') || a.warning.toLowerCase().includes('malicious')).length}
- **Total Indicators of Compromise (IOCs)**: ${(result.indicators?.ips || []).length + (result.indicators?.domains || []).length + (result.indicators?.emails || []).length}

### Top Key Findings
${(result.keyFindings || []).length > 0 ? (result.keyFindings || []).slice(0, 3).map(finding => `- **${finding.finding}** - ${finding.severity}`).join('\n') : 'The analysis did not flag any critical issues.'}

### Top MITRE ATT&CK Techniques
${(result.mitreAttackTechniques || []).length > 0 ? (result.mitreAttackTechniques || []).slice(0, 4).map(technique => `- **${technique.techniqueId}**: ${technique.techniqueName}`).join('\n') : 'No specific MITRE ATT&CK® techniques were identified.'}

---

## Email Details

### Basic Information

| Field | Value |
|-------|-------|
| From | ${result.emailInfo?.from || 'N/A'} |
| To | ${result.emailInfo?.to || 'N/A'} |
| Reply To | ${result.emailInfo?.replyTo || 'N/A'} |
| Subject | ${result.emailInfo?.subject || 'N/A'} |
| Date | ${result.emailInfo?.date || 'N/A'} |
| File Hash (SHA-256) | ${result.emailInfo?.fileHash || 'N/A'} |
| Authentication Results | ${result.emailInfo?.authenticationResults || 'N/A'} |

### Content Overview
${result.emailInfo?.bodySnippet || 'No body snippet available'}

---

## Headers Analysis

### Authentication Analysis

#### SPF
**Status**: ${result.headerAnalysis?.spfResult?.status || 'N/A'}  
**Explanation**: ${result.headerAnalysis?.spfResult?.explanation || 'N/A'}

#### DKIM
**Status**: ${result.headerAnalysis?.dkimResult?.status || 'N/A'}  
**Explanation**: ${result.headerAnalysis?.dkimResult?.explanation || 'N/A'}

#### DMARC
**Status**: ${result.headerAnalysis?.dmarcResult?.status || 'N/A'}  
**Explanation**: ${result.headerAnalysis?.dmarcResult?.explanation || 'N/A'}

### Delivery Path (Received Headers)
${(result.headerAnalysis?.receivedPath || []).length > 0 ? (result.headerAnalysis?.receivedPath || []).map((hop, index) => `#### Hop ${index + 1}
**From**: ${hop.from}  
**By**: ${hop.by}  
**Protocol**: ${hop.protocol}  
**Timestamp**: ${hop.timestamp}  
**Analysis**: ${hop.analysis}`).join('\n\n') : 'No delivery path information (Received headers) was found or could be parsed from the email.'}

---

## Risk Factors

### Score Calculation
${result.riskScoreAnalysis?.scoreCalculation || 'No score calculation available. The AI did not provide a step-by-step calculation for this score.'}

### Positive Factors
${(result.riskScoreAnalysis?.positiveFactors || []).length > 0 ? (result.riskScoreAnalysis?.positiveFactors || []).map(factor => `- **${factor.description}** - ${factor.impact}`).join('\n') : 'No positive factors listed.'}

### Negative Factors
${(result.riskScoreAnalysis?.negativeFactors || []).length > 0 ? (result.riskScoreAnalysis?.negativeFactors || []).map(factor => `- **${factor.description}** - ${factor.impact}`).join('\n') : 'No negative factors listed.'}

### Key Risk Metrics
${(result.keyFindings || []).length > 0 && (result.riskScoreAnalysis?.positiveFactors || []).length > 0 && (result.riskScoreAnalysis?.negativeFactors || []).length > 0 ? '' : 'The risk score was primarily determined by qualitative content analysis.'}

---

## Key Findings

${(result.keyFindings || []).length > 0 ? (result.keyFindings || []).map((finding, index) => `### ${index + 1}. ${finding.finding}

**Severity**: ${finding.severity}  
**Source**: ${finding.source}  
**Explanation**: ${finding.explanation}`).join('\n\n') : 'The analysis did not flag any critical issues contributing to the risk score.'}

---

## Indicators of Compromise (IOCs)

### IP Addresses
${(result.indicators?.ips || []).length > 0 ? `| IP | Type | City | Region | Country | Country Code | Postal Code | Latitude | Longitude | Timezone | Timezone Offset | ISP | Organization | ASN | ASN Route | Domain | Hostname | Anycast | Anonymous | Proxy | VPN | Tor | Hosting | Analysis |
|----|------|------|--------|---------|-------------|-------------|----------|-----------|----------|----------------|-----|-------------|-----|-----------|-------|----------|---------|----------|-------|-----|-----|--------|----------|
${(result.indicators?.ips || []).map(ip => `| ${ip.ip} | ${ip.type} | ${ip.geolocation?.city || 'N/A'} | ${ip.geolocation?.region || 'N/A'} | ${ip.geolocation?.country || 'N/A'} | ${ip.geolocation?.countryCode || 'N/A'} | ${ip.geolocation?.postalCode || 'N/A'} | ${ip.latitude ?? 'N/A'} | ${ip.longitude ?? 'N/A'} | ${ip.geolocation?.timezoneId || 'N/A'} | ${ip.geolocation?.timezoneOffset || 'N/A'} | ${ip.network?.isp || 'N/A'} | ${ip.network?.organization || 'N/A'} | ${ip.network?.asn || 'N/A'} | ${ip.network?.asnRoute || 'N/A'} | ${ip.network?.asnDomain || 'N/A'} | ${ip.hostname || 'N/A'} | ${ip.isAnycast ? 'Yes' : 'No'} | ${ip.security?.anonymous ? 'Yes' : 'No'} | ${ip.security?.proxy ? 'Yes' : 'No'} | ${ip.security?.vpn ? 'Yes' : 'No'} | ${ip.security?.tor ? 'Yes' : 'No'} | ${ip.security?.hosting ? 'Yes' : 'No'} | ${ip.analysis} |`).join('\n')}` : 'No IP addresses were found in the email to analyze.'}

### Domains
${(result.indicators?.domains || []).length > 0 ? `| Domain | Type | Analysis |
|--------|------|----------|
${(result.indicators?.domains || []).map(domain => `| ${domain.domain} | ${domain.type} | ${domain.analysis} |`).join('\n')}` : 'No domain indicators found.'}

### Email Addresses
${(result.indicators?.emails || []).length > 0 ? `| Email | Type | Analysis |
|-------|------|----------|
${(result.indicators?.emails || []).map(email => `| ${email.email} | ${email.type} | ${email.analysis} |`).join('\n')}` : 'No email indicators found.'}

### Summary
${((result.indicators?.ips || []).length > 0 || (result.indicators?.domains || []).length > 0 || (result.indicators?.emails || []).length > 0) ? '' : 'No email or domain indicators of compromise were found.'}

---

## URLs Analysis

${(result.urls || []).length > 0 ? (result.urls || []).map((url, index) => `### ${index + 1}. ${url.url}

**Verdict**: ${url.verdict}  
**Safety Score**: ${url.safetyScore}  
**Verdict Reason**: ${url.verdictReason}  
**Detailed Analysis**: ${url.detailedAnalysis}

#### Positive Signals
${(url.positiveSignals || []).length > 0 ? (url.positiveSignals || []).map(signal => `- ${signal}`).join('\n') : 'No positive signals found.'}

#### Negative Signals
${(url.negativeSignals || []).length > 0 ? (url.negativeSignals || []).map(signal => `- ${signal}`).join('\n') : 'No negative signals found.'}`).join('\n\n') : 'The analysis did not find any hyperlinks in the email\'s body or headers.'}

---

## Attachments

${(result.attachments || []).length > 0 ? (result.attachments || []).map((attachment, index) => `### ${index + 1}. ${attachment.filename}

**File Type**: ${attachment.filetype}  
**Size**: ${formatBytes(attachment.sizeInBytes)}  
**Warning**: ${attachment.warning}`).join('\n\n') : 'The analysis did not find any attachments in this email.'}

---

## Geolocation Analysis

### IP Addresses with Geolocation Data
${((result.indicators?.ips || []).filter(ip => ip.latitude != null && ip.longitude != null && !(ip.latitude === 0 && ip.longitude === 0)).length > 0) ? `| IP | Type | Location | Coordinates | ISP |
|----|------|----------|-------------|-----|
${(result.indicators?.ips || []).filter(ip => ip.latitude != null && ip.longitude != null && !(ip.latitude === 0 && ip.longitude === 0)).map(ip => `| ${ip.ip} | ${ip.type} | ${getLocationText(ip)} | ${(ip.latitude as number).toFixed(4)}, ${(ip.longitude as number).toFixed(4)} | ${ip.network?.isp || 'N/A'} |`).join('\n')}` : 'No IP addresses were found in the email to geolocate.'}

---

## Attack Vectors (MITRE ATT&CK Techniques)

${(result.mitreAttackTechniques || []).length > 0 ? (result.mitreAttackTechniques || []).map((technique, index) => `### ${index + 1}. ${technique.techniqueId}: ${technique.techniqueName}

${technique.description}`).join('\n\n') : 'The AI analysis did not identify any specific MITRE ATT&CK® techniques in this email.'}

---

## Threat Path Analysis

### Sender Information
${result.emailInfo?.from || 'N/A'}

### Authentication Status
- SPF: ${result.headerAnalysis?.spfResult?.status || 'N/A'}
- DKIM: ${result.headerAnalysis?.dkimResult?.status || 'N/A'}
- DMARC: ${result.headerAnalysis?.dmarcResult?.status || 'N/A'}

### Delivery Vectors
${((result.urls || []).filter(u => u.verdict === 'Caution' || u.verdict === 'Suspicious').length > 0 || (result.attachments || []).filter(a => a.warning.toLowerCase().includes('high-risk') || a.warning.toLowerCase().includes('malicious')).length > 0) ? `${(result.urls || []).filter(u => u.verdict === 'Caution' || u.verdict === 'Suspicious').map(url => `- ${url.url}`).join('\n')}
${(result.attachments || []).filter(a => a.warning.toLowerCase().includes('high-risk') || a.warning.toLowerCase().includes('malicious')).map(attachment => `- ${attachment.filename}`).join('\n')}` : 'No high-risk delivery vectors identified.'}

### Attack Objectives
${(result.mitreAttackTechniques || []).length > 0 ? (result.mitreAttackTechniques || []).map(technique => `- ${technique.techniqueName}`).join('\n') : 'No specific attack objectives identified.'}

### Key Findings
${((result.keyFindings || []).filter(f => f.severity === 'Critical' || f.severity === 'High').length > 0) ? (result.keyFindings || []).filter(f => f.severity === 'Critical' || f.severity === 'High').map(f => `- ${f.finding}`).join('\n') : 'No high-severity findings identified.'}

---

## Statistics

### URL Verdicts Distribution
- **Safe**: ${(result.urls || []).filter(u => u.verdict === 'Safe').length}
- **Caution**: ${(result.urls || []).filter(u => u.verdict === 'Caution').length}
- **Suspicious**: ${(result.urls || []).filter(u => u.verdict === 'Suspicious').length}
- **Manual Review**: ${(result.urls || []).filter(u => u.verdict === 'Manual Review').length}

### IP Types Distribution
- **Origin**: ${(result.indicators?.ips || []).filter(ip => ip.type === 'origin').length}
- **Hop**: ${(result.indicators?.ips || []).filter(ip => ip.type === 'hop').length}

---

## Recommended Actions

${(result.recommendedActions || []).length > 0 ? (result.recommendedActions || []).map((action, index) => `### ${index + 1}. ${action.action}

${action.details.map(detail => `- ${detail}`).join('\n')}`).join('\n\n') : 'No specific actions are recommended at this time based on the analysis.'}

---

## Raw Email Source

<div style="background-color: #2d3748; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; font-family: monospace; overflow-x: auto;">
${result.rawEml || 'No raw email source available'}
</div>

---

*This report is generated by [Nolvaryn](https://nolvaryn.com), an AI-powered email security platform.*
`;

  return markdown;
};

const formatBytes = (bytes: number, decimals = 2): string => {
  if (!bytes || bytes === 0) return '0 Bytes';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

const getLocationText = (ip: any): string => {
  if (!ip.geolocation) return 'N/A';
  const parts = [];
  if (ip.geolocation.city) parts.push(ip.geolocation.city);
  if (ip.geolocation.region) parts.push(ip.geolocation.region);
  if (ip.geolocation.country) parts.push(ip.geolocation.country);
  if (ip.network?.isp) parts.push(`(${ip.network.isp})`);
  return parts.length > 0 ? parts.join(', ') : 'N/A';
};
